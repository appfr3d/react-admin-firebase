{"version":3,"file":"index.js","sources":["../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/firestore-logger.ts","../src/misc/logger/logger.ts","../src/misc/dispatcher.ts","../src/misc/internal.models.ts","../src/misc/translate-from-firestore.ts","../src/misc/document-parser.ts","../src/misc/pathHelper.ts","../src/misc/translate-to-firestore.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/storage-parser.ts","../src/misc/metadata-parser.ts","../src/misc/firebase-models.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["import { get, isEmpty } from 'lodash';\nimport { getFieldReferences, SearchObj } from './objectFlatten';\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: 'asc' | 'desc'\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = get(a, field);\n    const rawB = get(b, field);\n    const isAsc = dir === 'asc';\n\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    if (isNumberField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\n    if (isStringField) {\n      const aParsed = rawA.toLowerCase();\n      const bParsed = rawB.toLowerCase();\n      return basicSort(aParsed, bParsed, isAsc);\n    }\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\n    if (isDateField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    return basicSort(!!rawA, !!rawB, isAsc);\n  });\n}\n\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\n  if (aValue > bValue) {\n    return isAsc ? 1 : -1;\n  }\n  if (aValue < bValue) {\n    return isAsc ? -1 : 1;\n  }\n  return 0;\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields?: { [field: string]: string | number | boolean | null }\n): Array<{}> {\n  if (!searchFields || isEmpty(searchFields)) {\n    return data;\n  }\n  const searchObjs: SearchObj[] = [];\n  Object.keys(searchFields).map((fieldName) => {\n    const fieldValue = searchFields[fieldName];\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\n    searchObjs.push(...getSubObjects);\n  });\n  const filtered = data.filter((row) =>\n    searchObjs.reduce((acc, cur) => {\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\n      return res && acc;\n    }, true as boolean)\n  );\n  return filtered;\n}\n\nexport function doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: any\n): boolean {\n  const searchThis = get(row, searchField);\n  const bothAreFalsey = !searchThis && !searchValue;\n  if (bothAreFalsey) {\n    return true;\n  }\n  const nothingToSearch = !searchThis;\n  if (nothingToSearch) {\n    return false;\n  }\n  const isStringSearch = typeof searchValue === 'string';\n  if (isStringSearch) {\n    return searchThis\n      .toString()\n      .toLowerCase()\n      .includes(searchValue.toLowerCase());\n  }\n  const isBooleanOrNumber =\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\n  if (isBooleanOrNumber) {\n    return searchThis === searchValue;\n  }\n  const isArraySearch = Array.isArray(searchValue);\n  if (isArraySearch) {\n    return searchValue.includes(searchThis);\n  }\n  return false;\n}\n","type SearchValues = {} | number | string | boolean | null;\ntype SearchValue = SearchValues | SearchValue[];\n\nexport interface SearchObj {\n  searchField: string;\n  searchValue: SearchValue;\n}\nexport function getFieldReferences(\n  fieldName: string,\n  value: {} | SearchValue\n): SearchObj[] {\n  const isFalsy = !value;\n  const isSimple =\n    isFalsy ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean';\n\n  if (isSimple) {\n    return [\n      {\n        searchField: fieldName,\n        searchValue: value as SearchValue,\n      },\n    ];\n  }\n  const tree = {} as Record<string, SearchValue>;\n  tree[fieldName] = value;\n  return objectFlatten(tree);\n}\n\nexport function objectFlatten(tree: {}): SearchObj[] {\n  var leaves: SearchObj[] = [];\n  var recursivelyWalk = (obj: any, path: string | null) => {\n    path = path || '';\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const objVal = obj && obj[key];\n        const currentPath = !!path ? path + '.' + key : key;\n        const isWalkable =\n          typeof objVal === 'object' || objVal instanceof Array;\n        if (isWalkable) {\n          recursivelyWalk(objVal, currentPath);\n        } else {\n          leaves.push({ searchField: currentPath, searchValue: objVal });\n        }\n      }\n    }\n  };\n  recursivelyWalk(tree, null);\n  return leaves;\n}\n","type LogFn = (...args: any) => void;\n\nexport const LogNoOp: LogFn = (...args: any) => null;\n\nexport class LoggerBase {\n  constructor(private title: string, private cacheEnabledKey: string) {}\n\n  private isEnabled() {\n    return !!localStorage.getItem(this.cacheEnabledKey);\n  }\n\n  SetEnabled(isEnabled: boolean) {\n    if (isEnabled) {\n      localStorage.setItem(this.cacheEnabledKey, 'true');\n    } else {\n      localStorage.removeItem(this.cacheEnabledKey);\n    }\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.log.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.warn.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n","import { RAFirebaseOptions } from 'providers/options';\nimport { LoggerBase, LogNoOp } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\n\nconst KEY_SINGLE = 'firecosts-single-reads';\n\nexport interface IFirestoreLogger {\n  logDocument: (count: number) => Function;\n  SetEnabled: (isEnabled: boolean) => void;\n  ResetCount: (shouldReset: boolean) => void;\n}\n\nexport function MakeFirestoreLogger(\n  options: RAFirebaseOptions\n): IFirestoreLogger {\n  function notEnabled() {\n    return !options?.lazyLoading?.enabled;\n  }\n\n  function incrementRead(incrementBy = 1) {\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\n    const currentCount = parseInt(currentCountRaw) || 0;\n    const incremented = currentCount + incrementBy;\n    localStorage.setItem(KEY_SINGLE, incremented + '');\n    return incremented;\n  }\n  function clearCache() {\n    localStorage.removeItem(KEY_SINGLE);\n  }\n  return {\n    SetEnabled(isEnabled: boolean) {\n      logger.SetEnabled(isEnabled);\n    },\n    ResetCount(shouldReset: boolean) {\n      shouldReset && clearCache();\n    },\n    logDocument(docCount: number) {\n      if (notEnabled()) {\n        return LogNoOp;\n      }\n      const count = incrementRead(docCount);\n      const suffix = `+${docCount} (session total=${count} documents read)`;\n      const boundLogFn: (...args: any) => void = logger.log.bind(\n        console,\n        suffix\n      );\n      return boundLogFn;\n    },\n  };\n}\n","import { LoggerBase } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\n\nexport const log = logger.log;\nexport const logError = logger.error;\nexport const logWarn = logger.warn;\n","import { log } from './logger';\n\nexport type DispatchEvent =\n  | 'FILE_UPLOAD_WILL_START'\n  | 'FILE_UPLOAD_PROGRESS'\n  | 'FILE_UPLOAD_PAUSED'\n  | 'FILE_UPLOAD_RUNNING'\n  | 'FILE_UPLOAD_CANCELED'\n  | 'FILE_UPLOAD_COMPLETE'\n  | 'FILE_SAVED';\n\nexport function dispatch(\n  eventName: DispatchEvent,\n  fileName: string,\n  data?: any\n): void {\n  const eventMonitor = document.getElementById('eventMonitor');\n  if (!eventMonitor) {\n    log(\n      `eventMonitor not found to dispatch event ${eventName} for ${fileName}`\n    );\n    return;\n  }\n  const eventData = { fileName, data };\n  let event = new CustomEvent(eventName, { detail: eventData });\n  eventMonitor.dispatchEvent(event);\n}\n","export const REF_INDENTIFIER = '___REF_FULLPATH_';\n\nexport interface ParsedRefDoc {\n  ___refpath: string;\n  ___refid: string;\n}\n","import { getDownloadURL, ref } from 'firebase/storage';\nimport { has, set } from 'lodash';\nimport { IFirebaseWrapper } from 'providers/database';\nimport { FireStoreDocumentRef } from './firebase-models';\nimport { REF_INDENTIFIER } from './internal.models';\nimport { logError } from './logger';\n\nexport interface RefDocFound {\n  fieldPath: string;\n  refDocPath: string;\n}\n\nexport interface FromFirestoreResult {\n  parsedDoc: any;\n  refdocs: RefDocFound[];\n}\n\nexport function translateDocFromFirestore(obj: any) {\n  const isObject = !!obj && typeof obj === 'object';\n  const result: FromFirestoreResult = {\n    parsedDoc: {},\n    refdocs: [],\n  };\n  if (!isObject) {\n    return result;\n  }\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    obj[key] = recusivelyCheckObjectValue(value, key, result);\n  });\n  result.parsedDoc = obj;\n  return result;\n}\n\nexport function recusivelyCheckObjectValue(\n  input: any,\n  fieldPath: string,\n  result: FromFirestoreResult\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as any[]).map((value, index) =>\n      recusivelyCheckObjectValue(value, `${fieldPath}.${index}`, result)\n    );\n  }\n  const isDocumentReference = isInputADocReference(input);\n  if (isDocumentReference) {\n    const documentReference = input as FireStoreDocumentRef;\n    result.refdocs.push({\n      fieldPath: fieldPath,\n      refDocPath: documentReference.path,\n    });\n    return documentReference.id;\n  }\n  const isObject = typeof input === 'object';\n  if (isObject) {\n    Object.keys(input).map((key) => {\n      const value = input[key];\n      input[key] = recusivelyCheckObjectValue(value, key, result);\n    });\n    return input;\n  }\n  return input;\n}\n\nfunction isInputADocReference(input: any): boolean {\n  const isDocumentReference =\n    typeof input.id === 'string' &&\n    typeof input.firestore === 'object' &&\n    typeof input.parent === 'object' &&\n    typeof input.path === 'string';\n  return isDocumentReference;\n}\n\nexport function applyRefDocs(doc: any, refDocs: RefDocFound[]) {\n  refDocs.map((d) => {\n    set(doc, REF_INDENTIFIER + d.fieldPath, d.refDocPath);\n  });\n  return doc;\n}\n\nexport const recursivelyMapStorageUrls = async (\n  fireWrapper: IFirebaseWrapper,\n  fieldValue: any\n): Promise<any> => {\n  const isPrimitive = !fieldValue || typeof fieldValue !== 'object';\n  if (isPrimitive) {\n    return fieldValue;\n  }\n  const isFileField = has(fieldValue, 'src');\n  if (isFileField) {\n    try {\n      const src = await getDownloadURL(\n        ref(fireWrapper.storage(), fieldValue.src)\n      );\n      return {\n        ...fieldValue,\n        src,\n      };\n    } catch (error) {\n      logError(`Error when getting download URL`, {\n        error,\n      });\n      return fieldValue;\n    }\n  }\n  const isArray = Array.isArray(fieldValue);\n  if (isArray) {\n    return Promise.all(\n      (fieldValue as any[]).map(async (value, index) => {\n        fieldValue[index] = await recursivelyMapStorageUrls(fireWrapper, value);\n      })\n    );\n  }\n  const isDocumentReference = isInputADocReference(fieldValue);\n  if (isDocumentReference) {\n    return fieldValue;\n  }\n  const isObject = !isArray && typeof fieldValue === 'object';\n  if (isObject) {\n    return Promise.all(\n      Object.keys(fieldValue).map(async (key) => {\n        const value = fieldValue[key];\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\n      })\n    );\n  }\n};\n","import {\n  FireStoreDocumentSnapshot,\n  FireStoreQueryDocumentSnapshot,\n} from './firebase-models';\nimport { logWarn } from './logger';\nimport * as ra from './react-admin-models';\nimport {\n  applyRefDocs,\n  translateDocFromFirestore,\n} from './translate-from-firestore';\n\nexport function parseFireStoreDocument<T extends ra.Record>(\n  doc: FireStoreQueryDocumentSnapshot | FireStoreDocumentSnapshot | undefined\n): T {\n  if (!doc) {\n    logWarn('parseFireStoreDocument: no doc', { doc });\n    return {} as T;\n  }\n  const data = doc.data();\n  const result = translateDocFromFirestore(data);\n  const dataWithRefs = applyRefDocs(result.parsedDoc, result.refdocs);\n  // React Admin requires an id field on every document,\n  // So we can just use the firestore document id\n  return { id: doc.id, ...dataWithRefs } as T;\n}\n","import path from 'path-browserify';\n\nexport function getAbsolutePath(\n  rootRef: undefined | string | (() => string),\n  relativePath: string | null\n): string {\n  if (!rootRef) {\n    return relativePath + '';\n  }\n  if (!relativePath) {\n    throw new Error(\n      'Resource name must be a string of length greater than 0 characters'\n    );\n  }\n  const rootRefValue = typeof rootRef === 'string' ? rootRef : rootRef();\n  const withSlashes = path.join('/', rootRefValue, '/', relativePath, '/');\n  const slashCount = withSlashes.split('/').length - 1;\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\"\n    not a \"collection\"e.g. /collection/document/ or\n    /collection/document/collection/document/`);\n  }\n  return withSlashes.slice(1, -1);\n}\n\nexport function joinPaths(...args: string[]) {\n  return path.join(...args);\n}\n","import { REF_INDENTIFIER } from './internal.models';\n\ninterface ParsedUpload {\n  fieldDotsPath: string;\n  fieldSlashesPath: string;\n  rawFile: File | any;\n}\n\ninterface ParsedDocRef {\n  fieldDotsPath: string;\n  refPath: string;\n}\n\ninterface ParseResult {\n  parsedDoc: any;\n  uploads: ParsedUpload[];\n  refdocs: ParsedDocRef[];\n}\n\nexport function translateDocToFirestore(obj: any): ParseResult {\n  const isObject = !!obj && typeof obj === 'object';\n  const result: ParseResult = {\n    uploads: [],\n    refdocs: [],\n    parsedDoc: {},\n  };\n  if (!isObject) {\n    return result;\n  }\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    recusivelyParseObjectValue(value, key, result);\n  });\n  result.parsedDoc = obj;\n  return result;\n}\n\nexport function recusivelyParseObjectValue(\n  input: any,\n  fieldPath: string,\n  result: ParseResult\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isRefField =\n    typeof fieldPath === 'string' && fieldPath.includes(REF_INDENTIFIER);\n  if (isRefField) {\n    const refDocFullPath = input as string;\n    result.refdocs.push({\n      fieldDotsPath: fieldPath,\n      refPath: refDocFullPath,\n    });\n    return;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map((value, index) =>\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, result)\n    );\n  }\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\n  if (isFileField) {\n    result.uploads.push({\n      fieldDotsPath: fieldPath,\n      fieldSlashesPath: fieldPath.split('.').join('/'),\n      rawFile: input.rawFile,\n    });\n    delete input.rawFile;\n    return;\n  }\n  Object.keys(input).map((key) => {\n    const value = input[key];\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, result);\n  });\n  return input;\n}\n","import { FirebaseApp, getApp, getApps, initializeApp } from 'firebase/app';\nimport {\n  browserLocalPersistence,\n  browserSessionPersistence,\n  getAuth,\n  inMemoryPersistence,\n  onAuthStateChanged,\n  Persistence,\n  signInWithEmailAndPassword,\n  signOut,\n} from 'firebase/auth';\nimport {\n  collection,\n  doc,\n  getFirestore,\n  serverTimestamp as firestoreServerTimestamp,\n  writeBatch,\n} from 'firebase/firestore';\nimport {\n  getDownloadURL,\n  getStorage,\n  ref,\n  uploadBytesResumable,\n} from 'firebase/storage';\nimport {\n  FireApp,\n  FireAuth,\n  FireAuthUserCredentials,\n  FireStorage,\n  FireStoragePutFileResult,\n  FireStore,\n  FireStoreBatch,\n  FireStoreCollectionRef,\n  FireUploadTaskSnapshot,\n  FireUser,\n} from 'misc/firebase-models';\nimport { log } from '../../../misc';\nimport { RAFirebaseOptions } from '../../options';\nimport { IFirebaseWrapper } from './IFirebaseWrapper';\n\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private readonly _app: FireApp;\n  private readonly _firestore: FireStore;\n  private readonly _storage: FireStorage;\n  private readonly _auth: FireAuth;\n  public options: RAFirebaseOptions;\n\n  constructor(inputOptions: RAFirebaseOptions | undefined, firebaseConfig: {}) {\n    const optionsSafe = inputOptions || {};\n    this.options = optionsSafe;\n    this._app = (window as any)['_app'] = ObtainFirebaseApp(\n      firebaseConfig,\n      optionsSafe\n    );\n    this._firestore = optionsSafe.firestore || getFirestore(this._app);\n    this._storage = optionsSafe.storage || getStorage(this._app);\n    this._auth = optionsSafe.auth || getAuth(this._app);\n  }\n  dbGetCollection(absolutePath: string): FireStoreCollectionRef {\n    return collection(this._firestore, absolutePath);\n  }\n  dbCreateBatch(): FireStoreBatch {\n    return writeBatch(this._firestore);\n  }\n  dbMakeNewId(): string {\n    return doc(collection(this._firestore, 'collections')).id;\n  }\n\n  public OnUserLogout(callBack: (u: FireUser | null) => any) {\n    this._auth.onAuthStateChanged((user) => {\n      const isLoggedOut = !user;\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\n      if (isLoggedOut) {\n        callBack(user);\n      }\n    });\n  }\n  putFile(storagePath: string, rawFile: any): FireStoragePutFileResult {\n    const task = uploadBytesResumable(ref(this._storage, storagePath), rawFile);\n    const taskResult = new Promise<FireUploadTaskSnapshot>((res, rej) =>\n      task.then(res).catch(rej)\n    );\n\n    const downloadUrl = taskResult\n      .then((t) => getDownloadURL(t.ref))\n      .then((url) => url as string);\n\n    return {\n      task,\n      taskResult,\n      downloadUrl,\n    };\n  }\n  async getStorageDownloadUrl(fieldSrc: string): Promise<string> {\n    return getDownloadURL(ref(this._storage, fieldSrc));\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    return firestoreServerTimestamp();\n  }\n\n  async authSetPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    let persistenceResolved: Persistence;\n    switch (persistenceInput) {\n      case 'local':\n        persistenceResolved = browserLocalPersistence;\n        break;\n      case 'none':\n        persistenceResolved = inMemoryPersistence;\n        break;\n      case 'session':\n      default:\n        persistenceResolved = browserSessionPersistence;\n        break;\n    }\n\n    log('setPersistence', { persistenceInput, persistenceResolved });\n\n    return this._auth\n      .setPersistence(persistenceResolved)\n      .catch((error) => console.error(error));\n  }\n  async authSigninEmailPassword(\n    email: string,\n    password: string\n  ): Promise<FireAuthUserCredentials> {\n    const user = await signInWithEmailAndPassword(this._auth, email, password);\n    return user;\n  }\n  async authSignOut(): Promise<void> {\n    return signOut(this._auth);\n  }\n  async authGetUserLoggedIn(): Promise<FireUser> {\n    return new Promise((resolve, reject) => {\n      const auth = this._auth;\n      if (auth.currentUser) return resolve(auth.currentUser);\n      const unsubscribe = onAuthStateChanged(this._auth, (user) => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n  public async GetUserLogin(): Promise<FireUser> {\n    return this.authGetUserLoggedIn();\n  }\n\n  /** @deprecated */\n  public auth(): FireAuth {\n    return this._auth;\n  }\n  /** @deprecated */\n  public storage(): FireStorage {\n    return this._storage;\n  }\n  /** @deprecated */\n  public GetApp(): FireApp {\n    return this._app;\n  }\n  /** @deprecated */\n  public db(): FireStore {\n    return this._firestore;\n  }\n}\n\nfunction ObtainFirebaseApp(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): FirebaseApp {\n  if (options.app) {\n    return options.app;\n  }\n  const apps = getApps();\n\n  const isInitialized = !!apps?.length;\n\n  if (isInitialized) {\n    return getApp();\n  } else {\n    return initializeApp(firebaseConfig);\n  }\n}\n","import { log, logger, logWarn, retrieveStatusTxt } from '../misc';\nimport { FireUser } from '../misc/firebase-models';\nimport {\n  AuthProvider as RaAuthProvider,\n  UserIdentity,\n} from '../misc/react-admin-models';\nimport { messageTypes } from './../misc/messageTypes';\nimport { IFirebaseWrapper } from './database';\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\nimport { RAFirebaseOptions } from './options';\n\nclass AuthClient {\n  private fireWrapper: IFirebaseWrapper;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log('Auth Client: initializing...', { firebaseConfig, options });\n    this.fireWrapper = new FirebaseWrapper(options, firebaseConfig);\n    options.persistence && this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    return this.fireWrapper.authSetPersistence(persistenceInput);\n  }\n\n  public async HandleAuthLogin(params: { username: string; password: string }) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.fireWrapper.authSigninEmailPassword(\n          username,\n          password\n        );\n        log('HandleAuthLogin: user sucessfully logged in', { user });\n        return user;\n      } catch (e) {\n        log('HandleAuthLogin: invalid credentials', { params });\n        throw new Error('Login error: invalid credentials');\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.fireWrapper.authSignOut();\n  }\n\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\n    const status = !!errorHttp && errorHttp.status;\n    const statusTxt = retrieveStatusTxt(status);\n    if (statusTxt === 'ok') {\n      log('API is actually authenticated');\n      return Promise.resolve();\n    }\n    logWarn('Received authentication error from API');\n    return Promise.reject();\n  }\n\n  public async HandleAuthCheck(): Promise<any> {\n    return this.getUserLogin();\n  }\n\n  public getUserLogin(): Promise<FireUser> {\n    return this.fireWrapper.authGetUserLoggedIn();\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetIdentity(): Promise<UserIdentity> {\n    try {\n      const { uid, displayName, photoURL } = await this.getUserLogin();\n      const identity: UserIdentity = {\n        id: uid,\n        fullName: `${displayName ?? ''}`,\n        avatar: `${photoURL ?? ''}`,\n      };\n      return identity;\n    } catch (e) {\n      log('HandleGetIdentity: no user is logged in', {\n        e,\n      });\n      return null as any;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log('HandleGetJWTToken: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): ReactAdminFirebaseAuthProvider {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  logger.SetEnabled(!!options?.logging);\n  const auth = new AuthClient(firebaseConfig, options);\n\n  const provider: ReactAdminFirebaseAuthProvider = {\n    // React Admin Interface\n    login: (params) => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: (error) => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getIdentity: () => auth.HandleGetIdentity(),\n    // Custom Functions\n    getAuthUser: () => auth.getUserLogin(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken(),\n  };\n  return provider;\n}\n\nexport type ReactAdminFirebaseAuthProvider = RaAuthProvider & {\n  // Custom Functions\n  getAuthUser: () => Promise<FireUser>;\n  getJWTAuthTime: () => Promise<string | null>;\n  getJWTExpirationTime: () => Promise<string | null>;\n  getJWTSignInProvider: () => Promise<string | null>;\n  getJWTClaims: () => Promise<{ [key: string]: any } | null>;\n  getJWTToken: () => Promise<string | null>;\n};\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n}\n","// From firebase SDK\n\nimport { logError } from './logger';\n\n// tslint:disable-next-line:max-line-length\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\n  // Make sure any successful status is OK.\n  if (status >= 200 && status < 300) {\n    return 'ok';\n  }\n  switch (status) {\n    case 401: // 'unauthenticated'\n    case 403: // 'permission-denied'\n      return 'unauthenticated';\n\n    case 0: // 'internal'\n    case 400: // 'invalid-argument'\n    case 404: // 'not-found'\n    case 409: // 'aborted'\n    case 429: // 'resource-exhausted'\n    case 499: // 'cancelled'\n    case 500: // 'internal'\n    case 501: // 'unimplemented'\n    case 503: // 'unavailable'\n    case 504: // 'deadline-exceeded'\n    default:\n      // ignore\n      return 'ok';\n  }\n}\n\n// From firebase SDK\n// tslint:disable-next-line:max-line-length\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusCode(statusTxt: string): number {\n  // Make sure any successful status is OK.\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\n  const status = Array.isArray(regexResult) && regexResult[1];\n  if (!status) {\n    logError('unknown StatusCode ', { statusTxt });\n  }\n  switch (status) {\n    case 'unauthenticated':\n      return 401;\n    case 'permission-denied':\n      return 403;\n    case 'internal':\n      return 0;\n    case 'invalid-argument':\n      return 400;\n    case 'not-found':\n      return 404;\n    case 'aborted':\n      return 409;\n    case 'resource-exhausted':\n      return 429;\n    case 'cancelled':\n      return 499;\n    case 'internal':\n      return 500;\n    case 'unimplemented':\n      return 501;\n    case 'unavailable':\n      return 503;\n    case 'deadline-exceeded':\n      return 504;\n    default:\n      return 200;\n  }\n}\n","import { doc, getDoc, getDocs } from 'firebase/firestore';\nimport { FireStoreCollectionRef, FireStoreQuery } from 'misc/firebase-models';\nimport {\n  getAbsolutePath,\n  IFirestoreLogger,\n  log,\n  logWarn,\n  messageTypes,\n  parseFireStoreDocument,\n} from '../../misc';\nimport { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\n\ntype IResourceItem = {} & { id: string; deleted?: boolean };\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: FireStoreCollectionRef;\n  list: Array<IResourceItem>;\n}\n\nexport class ResourceManager {\n  private resources: Record<string, IResource> = {};\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions,\n    private flogger: IFirestoreLogger\n  ) {\n    this.fireWrapper.OnUserLogout(() => {\n      this.resources = {};\n    });\n  }\n\n  public async TryGetResource(\n    resourceName: string,\n    refresh?: 'REFRESH',\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log('resourceManager.TryGetResourcePromise', {\n      relativePath,\n      collectionQuery,\n    });\n    await this.initPath(relativePath);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType | undefined\n  ) {\n    if (this.options?.lazyLoading?.enabled) {\n      logWarn('resourceManager.RefreshResource', {\n        warn: 'RefreshResource is not available in lazy loading mode',\n      });\n      throw new Error(\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\n      );\n    }\n\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n\n    const collectionRef = resource.collection;\n    const collectionOrQuery = this.applyQuery(collectionRef, collectionQuery);\n    const newDocs = await getDocs(collectionOrQuery);\n\n    resource.list = [];\n    newDocs.forEach((d) =>\n      resource.list.push(parseFireStoreDocument<IResourceItem>(d))\n    );\n\n    const count = newDocs.docs.length;\n    this.flogger.logDocument(count)();\n    log('resourceManager.RefreshResource', {\n      newDocs,\n      resource,\n      collectionPath: collectionRef.path,\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.GetResource(relativePath);\n    this.flogger.logDocument(1)();\n    const docSnap = await getDoc(doc(resource.collection, docId));\n    if (!docSnap.exists) {\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\n    }\n    const result = parseFireStoreDocument(docSnap);\n    log('resourceManager.GetSingleDoc', {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result,\n    });\n    return result;\n  }\n\n  private async initPath(relativePath: string): Promise<void> {\n    const rootRef = this.options && this.options.rootRef;\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\n    const hasBeenInited = !!this.resources[relativePath];\n    log('resourceManager.initPath()', {\n      absolutePath,\n      hasBeenInited,\n    });\n    if (hasBeenInited) {\n      log('resourceManager.initPath() has been initialized already...');\n      return;\n    }\n    const collection = this.fireWrapper.dbGetCollection(absolutePath);\n    const list: Array<IResourceItem> = [];\n    const resource: IResource = {\n      collection,\n      list,\n      path: relativePath,\n      pathAbsolute: absolutePath,\n    };\n    this.resources[relativePath] = resource;\n    log('resourceManager.initPath() setting resource...', {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path,\n    });\n  }\n\n  public async getUserIdentifier(): Promise<string> {\n    const identifier = this.options.associateUsersById\n      ? await this.getCurrentUserId()\n      : await this.getCurrentUserEmail();\n    return identifier;\n  }\n\n  private async getCurrentUserEmail() {\n    const user = await this.fireWrapper.authGetUserLoggedIn();\n    if (user) {\n      return user.email as string;\n    } else {\n      return 'annonymous user';\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.fireWrapper.authGetUserLoggedIn();\n    if (user) {\n      return user.uid;\n    } else {\n      return 'annonymous user';\n    }\n  }\n\n  private applyQuery(\n    collection: FireStoreCollectionRef,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): FireStoreCollectionRef | FireStoreQuery {\n    const collRef = collectionQuery ? collectionQuery(collection) : collection;\n\n    log('resourceManager.applyQuery() ...', {\n      collection,\n      collectionQuery: (collectionQuery || '-').toString(),\n      collRef,\n    });\n    return collRef;\n  }\n}\n","import { doc } from 'firebase/firestore';\nimport { get, set } from 'lodash';\nimport {\n  AddCreatedByFields,\n  AddUpdatedByFields,\n  dispatch,\n  IFirestoreLogger,\n  log,\n  logError,\n  parseStoragePath,\n  translateDocToFirestore,\n} from '../../misc';\nimport {\n  TASK_CANCELED,\n  TASK_PAUSED,\n  TASK_RUNNING,\n} from '../../misc/firebase-models';\nimport { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\nimport { IResource, ResourceManager } from './ResourceManager';\n\nexport class FireClient {\n  public rm: ResourceManager;\n\n  constructor(\n    public fireWrapper: IFirebaseWrapper,\n    public options: RAFirebaseOptions,\n    public flogger: IFirestoreLogger\n  ) {\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\n  }\n\n  public checkRemoveIdField(obj: any, docId: string) {\n    if (!this.options.dontAddIdFieldToDoc) {\n      obj.id = docId;\n    }\n  }\n\n  public transformToDb(\n    resourceName: string,\n    documentData: any,\n    docId: string\n  ): any {\n    if (typeof this.options.transformToDb === 'function') {\n      return this.options.transformToDb(resourceName, documentData, docId);\n    }\n    return documentData;\n  }\n\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = doc(r.collection, id).path;\n\n    const result = translateDocToFirestore(data);\n    const uploads = result.uploads;\n    await Promise.all(\n      uploads.map(async (u) => {\n        const storagePath = parseStoragePath(\n          u.rawFile,\n          docPath,\n          u.fieldDotsPath,\n          !!this.options.useFileNamesInStorage\n        );\n        const link = await this.saveFile(storagePath, u.rawFile);\n        set(data, u.fieldDotsPath + '.src', link);\n      })\n    );\n    return data;\n  }\n\n  public async addCreatedByFields(obj: any) {\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  public async addUpdatedByFields(obj: any) {\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  private async saveFile(\n    storagePath: string,\n    rawFile: any\n  ): Promise<string | undefined> {\n    log('saveFile() saving file...', { storagePath, rawFile });\n    try {\n      const { task, taskResult, downloadUrl } = this.fireWrapper.putFile(\n        storagePath,\n        rawFile\n      );\n      const { name } = rawFile;\n      // monitor upload status & progress\n      dispatch('FILE_UPLOAD_WILL_START', name);\n      task.on('state_changed', (snapshot) => {\n        const progress =\n          (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n        log('Upload is ' + progress + '% done');\n        dispatch('FILE_UPLOAD_PROGRESS', name, progress);\n        switch (snapshot.state) {\n          case TASK_PAUSED:\n            log('Upload is paused');\n            dispatch('FILE_UPLOAD_PAUSED', name);\n            break;\n          case TASK_RUNNING:\n            log('Upload is running');\n            dispatch('FILE_UPLOAD_RUNNING', name);\n            break;\n          case TASK_CANCELED:\n            log('Upload has been canceled');\n            dispatch('FILE_UPLOAD_CANCELED', name);\n            break;\n          // case storage.TaskState.ERROR:\n          // already handled by catch\n          // case storage.TaskState.SUCCESS:\n          // already handled by then\n        }\n      });\n      const [getDownloadURL] = await Promise.all([downloadUrl, taskResult]);\n      dispatch('FILE_UPLOAD_COMPLETE', name);\n      dispatch('FILE_SAVED', name);\n      log('saveFile() saved file', {\n        storagePath,\n        taskResult,\n        getDownloadURL,\n      });\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\n    } catch (storageError) {\n      if (get(storageError, 'code') === 'storage/unknown') {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError('saveFile() error saving file', {\n          storageError,\n        });\n      }\n    }\n  }\n}\n","import { joinPaths } from './pathHelper';\n\nexport function parseStoragePath(\n  rawFile: File,\n  docPath: string,\n  fieldPath: string,\n  useFileName: boolean\n): string {\n  const fileNameBits = rawFile instanceof File ? rawFile.name.split('.') : [];\n\n  const fileExtension = !fileNameBits?.length ? '' : '.' + fileNameBits.pop();\n\n  return useFileName\n    ? joinPaths(docPath, fieldPath, rawFile.name)\n    : joinPaths(docPath, fieldPath + fileExtension);\n}\n","import { RAFirebaseOptions } from 'index';\nimport { IFirebaseWrapper, ResourceManager } from 'providers/database';\n\nexport async function AddCreatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\n  options: Pick<\n    RAFirebaseOptions,\n    | 'associateUsersById'\n    | 'disableMeta'\n    | 'renameMetaFields'\n    | 'metaFieldCasing'\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const createAtSelector = GetSelectorsCreateAt(options);\n  const createBySelector = GetSelectorsCreateBy(options);\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\n  obj[createBySelector] = currentUserIdentifier;\n}\n\nexport async function AddUpdatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\n  options: Pick<\n    RAFirebaseOptions,\n    | 'associateUsersById'\n    | 'disableMeta'\n    | 'renameMetaFields'\n    | 'metaFieldCasing'\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const updateAtSelector = GetSelectorsUpdateAt(options);\n  const updateBySelector = GetSelectorsUpdateBy(options);\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\n  obj[updateBySelector] = currentUserIdentifier;\n}\n\nexport function GetSelectorsUpdateAt(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\n    return options.renameMetaFields.updated_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'lastupdate';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'lastUpdate';\n  }\n  if (casing === 'snake') {\n    return 'last_update';\n  }\n  if (casing === 'pascal') {\n    return 'LastUpdate';\n  }\n  if (casing === 'kebab') {\n    return 'last-update';\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsUpdateBy(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\n    return options.renameMetaFields.updated_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'updatedby';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'updatedBy';\n  }\n  if (casing === 'snake') {\n    return 'updated_by';\n  }\n  if (casing === 'pascal') {\n    return 'UpdatedBy';\n  }\n  if (casing === 'kebab') {\n    return 'updated-by';\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateAt(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\n    return options.renameMetaFields.created_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'createdate';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'createDate';\n  }\n  if (casing === 'snake') {\n    return 'create_date';\n  }\n  if (casing === 'pascal') {\n    return 'CreateDate';\n  }\n  if (casing === 'kebab') {\n    return 'create-date';\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateBy(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\n    return options.renameMetaFields.created_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'createdby';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'createdBy';\n  }\n  if (casing === 'snake') {\n    return 'created_by';\n  }\n  if (casing === 'pascal') {\n    return 'CreatedBy';\n  }\n  if (casing === 'kebab') {\n    return 'created-by';\n  }\n  return defautCase;\n}\n","import { FirebaseApp } from 'firebase/app';\nimport { Auth, User, UserCredential } from 'firebase/auth';\nimport {\n  CollectionReference,\n  DocumentData,\n  DocumentReference,\n  DocumentSnapshot,\n  FieldValue,\n  Firestore,\n  OrderByDirection,\n  Query,\n  QueryDocumentSnapshot,\n  WriteBatch,\n} from 'firebase/firestore';\nimport {\n  FirebaseStorage,\n  StorageReference,\n  TaskState,\n  UploadTask,\n  UploadTaskSnapshot,\n} from 'firebase/storage';\n\nexport type FireUser = User;\nexport type FireApp = FirebaseApp;\n\nexport type FireStorage = FirebaseStorage;\nexport type FireStorageReference = StorageReference;\nexport type FireUploadTaskSnapshot = UploadTaskSnapshot;\nexport type FireUploadTask = UploadTask;\nexport type FireStoragePutFileResult = {\n  task: FireUploadTask;\n  taskResult: Promise<FireUploadTaskSnapshot>;\n  downloadUrl: Promise<string>;\n};\n\nexport type FireAuth = Auth;\nexport type FireAuthUserCredentials = UserCredential;\n\nexport type FireStore = Firestore;\nexport type FireStoreBatch = WriteBatch;\nexport type FireStoreTimeStamp = FieldValue;\nexport type FireStoreDocumentRef = DocumentReference;\nexport type FireStoreDocumentSnapshot = DocumentSnapshot<DocumentData>;\nexport type FireStoreCollectionRef = CollectionReference;\nexport type FireStoreQueryDocumentSnapshot = QueryDocumentSnapshot;\nexport type FireStoreQuery = Query;\nexport type FireStoreQueryOrder = OrderByDirection;\n\nexport const TASK_PAUSED = 'paused' as TaskState;\nexport const TASK_RUNNING = 'running' as TaskState;\nexport const TASK_CANCELED = 'cancelled' as TaskState;\n","import {\n  doc,\n  getDoc,\n  getDocs,\n  limit,\n  query,\n  QueryConstraint,\n  startAfter,\n  startAt,\n} from 'firebase/firestore';\nimport { ref } from 'firebase/storage';\nimport {\n  FireStoreCollectionRef,\n  FireStoreDocumentSnapshot,\n  FireStoreQuery,\n} from 'misc/firebase-models';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\n\nexport function setQueryCursor(\n  document: FireStoreDocumentSnapshot,\n  params: messageTypes.IParamsGetList,\n  resourceName: string\n) {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  localStorage.setItem(key, document.id);\n\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (!localCursorKeys) {\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\n  } else {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    const newCursors = cursors.concat(key);\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\n  }\n}\n\nexport async function getQueryCursor(\n  collection: FireStoreCollectionRef,\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<FireStoreDocumentSnapshot | false> {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  const docId = localStorage.getItem(key);\n  if (!docId) {\n    return false;\n  }\n\n  const docSnapshot = await getDoc(doc(collection, docId));\n  flogger.logDocument(1)();\n  if (docSnapshot.exists()) {\n    return docSnapshot;\n  }\n  return false;\n}\n\nexport function clearQueryCursors(resourceName: string) {\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (localCursorKeys) {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\n    localStorage.removeItem(allCursorsKey);\n  }\n}\n\nexport async function findLastQueryCursor(\n  collection: FireStoreCollectionRef,\n  queryConstraints: QueryConstraint[],\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n) {\n  const { page, perPage } = params.pagination;\n\n  let lastQueryCursor: FireStoreDocumentSnapshot | false = false;\n  let currentPage = page - 1;\n\n  const currentPageParams = {\n    ...params,\n    pagination: {\n      ...params.pagination,\n    },\n  };\n  while (!lastQueryCursor && currentPage > 1) {\n    currentPage--;\n    currentPageParams.pagination.page = currentPage;\n    console.log('getting query cursor currentPage=', currentPage);\n    lastQueryCursor = await getQueryCursor(\n      collection,\n      currentPageParams,\n      resourceName,\n      flogger\n    );\n  }\n  const pageLimit = (page - currentPage) * perPage;\n  const isFirst = currentPage === 1;\n\n  function getQuery() {\n    if (isFirst) {\n      return query(collection, ...[...queryConstraints, limit(pageLimit)]);\n    } else {\n      return query(\n        collection,\n        ...[...queryConstraints, startAfter(lastQueryCursor), limit(pageLimit)]\n      );\n    }\n  }\n\n  const newQuery = getQuery();\n  const snapshots = await getDocs(newQuery);\n  const docsLength = snapshots.docs.length;\n  flogger.logDocument(docsLength)();\n  const lastDocIndex = docsLength - 1;\n  const lastDocRef = snapshots.docs[lastDocIndex];\n  return lastDocRef;\n}\n","import {\n  getDocs,\n  limit,\n  orderBy,\n  query,\n  QueryConstraint,\n  startAfter,\n  where,\n} from 'firebase/firestore';\nimport {\n  FireStoreCollectionRef,\n  FireStoreQuery,\n  FireStoreQueryOrder,\n} from 'misc/firebase-models';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\n\ninterface ParamsToQueryOptions {\n  filters?: boolean;\n  sort?: boolean;\n  pagination?: boolean;\n}\n\ninterface QueryPair {\n  noPagination: FireStoreQuery;\n  withPagination: FireStoreQuery;\n}\n\nconst defaultParamsToQueryOptions = {\n  filters: true,\n  sort: true,\n  pagination: true,\n};\n\nexport async function paramsToQuery<\n  TParams extends messageTypes.IParamsGetList\n>(\n  collection: FireStoreCollectionRef,\n  params: TParams,\n  resourceName: string,\n  flogger: IFirestoreLogger,\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\n): Promise<QueryPair> {\n  const filterConstraints = options.filters\n    ? getFiltersConstraints(params.filter)\n    : [];\n\n  const sortConstraints = options.sort ? getSortConstraints(params.sort) : [];\n\n  const paginationConstraints = options.pagination\n    ? await getPaginationConstraints(\n        collection,\n        [...filterConstraints, ...sortConstraints],\n        params,\n        resourceName,\n        flogger\n      )\n    : [];\n\n  return {\n    noPagination: query(\n      collection,\n      ...[...filterConstraints, ...sortConstraints]\n    ),\n    withPagination: query(\n      collection,\n      ...[...filterConstraints, ...sortConstraints, ...paginationConstraints]\n    ),\n  };\n}\n\nexport function getFiltersConstraints(filters: {\n  [fieldName: string]: any;\n}): QueryConstraint[] {\n  return Object.entries(filters).flatMap(([fieldName, fieldValue]) => {\n    if (Array.isArray(fieldValue)) {\n      return [where(fieldName, 'array-contains-any', fieldValue)];\n    } else if (Object.keys(filters).length === 1 && isNaN(fieldValue)) {\n      return [\n        where(fieldName, '>=', fieldValue),\n        where(fieldName, '<', fieldValue + 'z'),\n      ];\n    } else {\n      return [where(fieldName, '==', fieldValue)];\n    }\n  });\n}\n\nexport function getSortConstraints(sort: {\n  field: string;\n  order: string;\n}): QueryConstraint[] {\n  if (sort != null && sort.field !== 'id') {\n    const { field, order } = sort;\n    const parsedOrder = order.toLocaleLowerCase() as FireStoreQueryOrder;\n    return [orderBy(field, parsedOrder)];\n  }\n  return [];\n}\n\nasync function getPaginationConstraints<\n  TParams extends messageTypes.IParamsGetList\n>(\n  collectionRef: FireStoreCollectionRef,\n  queryConstraints: QueryConstraint[],\n  params: TParams,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<QueryConstraint[]> {\n  const { page, perPage } = params.pagination;\n\n  if (page === 1) {\n    return [limit(perPage)];\n  } else {\n    let queryCursor = await getQueryCursor(\n      collectionRef,\n      params,\n      resourceName,\n      flogger\n    );\n    if (!queryCursor) {\n      queryCursor = await findLastQueryCursor(\n        collectionRef,\n        queryConstraints,\n        params,\n        resourceName,\n        flogger\n      );\n    }\n    return [startAfter(queryCursor), limit(perPage)];\n  }\n}\n\nexport function getFullParamsForQuery<\n  TParams extends messageTypes.IParamsGetList\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\n  return {\n    ...reactAdminParams,\n    filter: softdeleteEnabled\n      ? {\n          deleted: false,\n          ...reactAdminParams.filter,\n        }\n      : reactAdminParams.filter,\n  };\n}\n\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\n  params: TParams\n): TParams {\n  return {\n    ...params,\n    pagination: {\n      ...params.pagination,\n      page: params.pagination.page + 1,\n    },\n  };\n}\n","import { getCountFromServer, getDocs } from 'firebase/firestore';\nimport {\n  log,\n  messageTypes,\n  parseFireStoreDocument,\n  recursivelyMapStorageUrls,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient, IResource, ResourceManager } from '../database';\nimport { RAFirebaseOptions } from '../options';\nimport {\n  getFullParamsForQuery,\n  getNextPageParams,\n  paramsToQuery,\n} from './paramsToQuery';\nimport { setQueryCursor } from './queryCursors';\n\nexport class FirebaseLazyLoadingClient {\n  constructor(\n    private readonly options: RAFirebaseOptions,\n    private readonly rm: ResourceManager,\n    private client: FireClient\n  ) {}\n\n  public async apiGetList<T extends ra.Record>(\n    resourceName: string,\n    reactAdminParams: ra.GetListParams\n  ): Promise<ra.GetListResult<T>> {\n    const r = await this.tryGetResource(resourceName);\n    const params = getFullParamsForQuery(\n      reactAdminParams,\n      !!this.options.softDelete\n    );\n\n    log('apiGetListLazy', { resourceName, params });\n\n    const { noPagination, withPagination } = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await getDocs(withPagination);\n\n    const resultsCount = snapshots.docs.length;\n    if (!resultsCount) {\n      log('apiGetListLazy', {\n        message: 'There are not records for given query',\n      });\n      return { data: [], total: 0 };\n    }\n    this.client.flogger.logDocument(resultsCount)();\n\n    // tslint:disable-next-line\n    const data = snapshots.docs.map((d) => parseFireStoreDocument<T>(d));\n\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\n    // After fetching documents save queryCursor for next page\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\n    // Hardcoded to allow next pages, as we don't have total number of items\n\n    let total = await getCountFromServer(noPagination);\n\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetListLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total: total.data().count,\n      };\n    }\n\n    log('apiGetListLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n\n    return { data, total: total.data().count };\n  }\n\n  public async apiGetManyReference(\n    resourceName: string,\n    reactAdminParams: messageTypes.IParamsGetManyReference\n  ): Promise<messageTypes.IResponseGetManyReference> {\n    const r = await this.tryGetResource(resourceName);\n    log('apiGetManyReferenceLazy', {\n      resourceName,\n      resource: r,\n      reactAdminParams,\n    });\n    const filterWithTarget = {\n      ...reactAdminParams.filter,\n      [reactAdminParams.target]: reactAdminParams.id,\n    };\n    const params = getFullParamsForQuery(\n      {\n        ...reactAdminParams,\n        filter: filterWithTarget,\n      },\n      !!this.options.softDelete\n    );\n\n    const { withPagination } = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await getDocs(withPagination);\n    const resultsCount = snapshots.docs.length;\n    this.client.flogger.logDocument(resultsCount)();\n    const data = snapshots.docs.map(parseFireStoreDocument);\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetManyReferenceLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total: data.length,\n      };\n    }\n\n    log('apiGetManyReferenceLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n    return { data, total: data.length };\n  }\n\n  private async tryGetResource(\n    resourceName: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n}\n","import {\n  getAbsolutePath,\n  log,\n  logError,\n  logger,\n  MakeFirestoreLogger,\n  retrieveStatusCode,\n} from '../misc';\nimport { FireApp } from '../misc/firebase-models';\nimport * as ra from '../misc/react-admin-models';\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from './commands';\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\nimport { FireClient } from './database/FireClient';\nimport { RAFirebaseOptions } from './options';\nimport { GetList, GetMany, GetManyReference, GetOne } from './queries';\n\nexport interface IDataProvider extends ra.DataProvider {\n  app: FireApp;\n}\n\nexport function DataProvider(\n  firebaseConfig: {},\n  optionsInput?: RAFirebaseOptions\n): IDataProvider {\n  const options = optionsInput || {};\n  verifyDataProviderArgs(firebaseConfig, options);\n\n  const flogger = MakeFirestoreLogger(options);\n  logger.SetEnabled(!!options?.logging);\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\n  log('Creating FirebaseDataProvider', {\n    firebaseConfig,\n    options,\n  });\n\n  const fireWrapper = new FirebaseWrapper(optionsInput, firebaseConfig);\n\n  async function run<T>(cb: () => Promise<T>) {\n    let res: any;\n    try {\n      res = await cb();\n      return res;\n    } catch (error) {\n      const errorMsg = ((error as any) || '').toString();\n      const code = retrieveStatusCode(errorMsg);\n      const errorObj = { status: code, message: errorMsg, json: res };\n      logError('DataProvider:', error, { errorMsg, code, errorObj });\n      throw errorObj;\n    }\n  }\n  const client = new FireClient(fireWrapper, options, flogger);\n\n  const newProviderApi: IDataProvider = {\n    app: fireWrapper.GetApp(),\n    getList<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetListParams\n    ): Promise<ra.GetListResult<RecordType>> {\n      return run(() => GetList<RecordType>(resource, params, client));\n    },\n    getOne<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetOneParams\n    ): Promise<ra.GetOneResult<RecordType>> {\n      return run(() => GetOne<RecordType>(resource, params, client));\n    },\n    getMany<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyParams\n    ): Promise<ra.GetManyResult<RecordType>> {\n      return run(() => GetMany<RecordType>(resource, params, client));\n    },\n    getManyReference<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyReferenceParams\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\n      return run(() => GetManyReference<RecordType>(resource, params, client));\n    },\n    update<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.UpdateParams\n    ): Promise<ra.UpdateResult<RecordType>> {\n      return run(() => Update<RecordType>(resource, params, client));\n    },\n    updateMany(\n      resource: string,\n      params: ra.UpdateManyParams\n    ): Promise<ra.UpdateManyResult> {\n      return run(() => UpdateMany(resource, params, client));\n    },\n    create<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.CreateParams\n    ): Promise<ra.CreateResult<RecordType>> {\n      return run(() => Create<RecordType>(resource, params, client));\n    },\n    delete<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.DeleteParams\n    ): Promise<ra.DeleteResult<RecordType>> {\n      return run(() => Delete(resource, params, client));\n    },\n    deleteMany(\n      resource: string,\n      params: ra.DeleteManyParams\n    ): Promise<ra.DeleteManyResult> {\n      return run(() => DeleteMany(resource, params, client));\n    },\n  };\n\n  return newProviderApi;\n}\n\nfunction verifyDataProviderArgs(\n  firebaseConfig: {},\n  options?: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n  if (options && options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, 'test');\n  }\n}\n","import {\n  filterArray,\n  log,\n  recursivelyMapStorageUrls,\n  sortArray,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\n\nexport async function GetList<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetListParams,\n  client: FireClient\n): Promise<ra.GetListResult<T>> {\n  log('GetList', { resourceName, params });\n  const { rm, fireWrapper, options } = client;\n\n  if (options?.lazyLoading?.enabled) {\n    const lazyClient = new FirebaseLazyLoadingClient(options, rm, client);\n    return lazyClient.apiGetList<T>(resourceName, params);\n  }\n\n  const filterSafe = params.filter || {};\n\n  const collectionQuery = filterSafe.collectionQuery;\n  delete filterSafe.collectionQuery;\n\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\n  const data = r.list;\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === 'ASC') {\n      sortArray(data, field, 'asc');\n    } else {\n      sortArray(data, field, 'desc');\n    }\n  }\n  let softDeleted = data;\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\n    softDeleted = data.filter((doc) => !doc.deleted);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\n  const total = filteredData.length;\n\n  if (options.relativeFilePaths) {\n    const fetchedData = await Promise.all(\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data: fetchedData,\n      total,\n    };\n  }\n\n  return {\n    data: dataPage,\n    total,\n  };\n}\n","import { log, translateDocFromFirestore } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function GetOne<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetOneParams,\n  client: FireClient\n): Promise<ra.GetOneResult<T>> {\n  log('GetOne', { resourceName, params });\n  const { rm } = client;\n  try {\n    const id = params.id + '';\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\n    client.flogger.logDocument(1)();\n    return { data: dataSingle as T };\n  } catch (error) {\n    throw new Error(\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\n    );\n  }\n}\n","import { doc, getDoc } from 'firebase/firestore';\nimport { log, recursivelyMapStorageUrls } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function GetMany<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyParams,\n  client: FireClient\n): Promise<ra.GetManyResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  const ids = params.ids;\n  log('GetMany', { resourceName, resource: r, params, ids });\n  const matchDocSnaps = await Promise.all(\n    ids.map((idObj) => {\n      if (typeof idObj === 'string') {\n        return getDoc(doc(r.collection, idObj));\n      }\n      // Will get and resolve reference documents into the current doc\n      return getDoc(doc(r.collection, (idObj as any)['___refid']));\n    })\n  );\n  client.flogger.logDocument(ids.length)();\n  const matches = matchDocSnaps.map(\n    (snap) => ({ ...snap.data(), id: snap.id } as T)\n  );\n  const permittedData = options.softDelete\n    ? matches.filter((row) => !row['deleted'])\n    : matches;\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((d) => recursivelyMapStorageUrls(fireWrapper, d))\n    );\n    return {\n      data,\n    };\n  }\n\n  return {\n    data: permittedData,\n  };\n}\n","import {\n  filterArray,\n  log,\n  recursivelyMapStorageUrls,\n  sortArray,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function GetManyReference<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyReferenceParams,\n  client: FireClient\n): Promise<ra.GetManyReferenceResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  log('GetManyReference', { resourceName, params });\n  const filterSafe = params.filter || {};\n  const collectionQuery = filterSafe.collectionQuery;\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\n  delete filterSafe.collectionQuery;\n  log('apiGetManyReference', { resourceName, resource: r, params });\n  const data = r.list;\n  const targetField = params.target;\n  const targetValue = params.id;\n  let softDeleted = data;\n  if (options.softDelete) {\n    softDeleted = data.filter((doc) => !doc['deleted']);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const targetIdFilter: Record<string, ra.Identifier> = {};\n  targetIdFilter[targetField] = targetValue;\n  const permittedData = filterArray(filteredData, targetIdFilter);\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === 'ASC') {\n      sortArray(permittedData, field, 'asc');\n    } else {\n      sortArray(permittedData, field, 'desc');\n    }\n  }\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\n  const total = permittedData.length;\n\n  if (options.relativeFilePaths) {\n    const fetchedData = await Promise.all(\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return { data: fetchedData, total };\n  }\n\n  return { data: dataPage, total };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function Update<T extends ra.Record>(\n  resourceName: string,\n  params: ra.UpdateParams,\n  client: FireClient\n): Promise<ra.UpdateResult<T>> {\n  const { rm } = client;\n  log('Update', { resourceName, params });\n  const id = params.id + '';\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log('Update', { resourceName, resource: r, params });\n  const data = await client.parseDataAndUpload(r, id, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, id);\n  await client.addUpdatedByFields(docObj);\n  const docObjTransformed = client.transformToDb(resourceName, docObj, id);\n  await updateDoc(doc(r.collection, id), docObjTransformed);\n  return {\n    data: {\n      ...data,\n      id: id,\n    },\n  };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function UpdateMany(\n  resourceName: string,\n  params: ra.UpdateManyParams,\n  client: FireClient\n): Promise<ra.UpdateManyResult> {\n  const { rm } = client;\n  log('UpdateMany', { resourceName, params });\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log('UpdateMany', { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + '';\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\n      const docObj = { ...data };\n      client.checkRemoveIdField(docObj, idStr);\n      await client.addUpdatedByFields(docObj);\n      const docObjTransformed = client.transformToDb(\n        resourceName,\n        docObj,\n        idStr\n      );\n      await updateDoc(doc(r.collection, idStr), docObjTransformed);\n      return {\n        ...data,\n        id: idStr,\n      };\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n","import { doc, getDoc, setDoc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function Create<T extends ra.Record>(\n  resourceName: string,\n  params: ra.CreateParams,\n  client: FireClient\n): Promise<ra.CreateResult<T>> {\n  const { rm, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log('Create', { resourceName, resource: r, params });\n  const hasOverridenDocId = params.data && params.data.id;\n  log('Create', { hasOverridenDocId });\n  if (hasOverridenDocId) {\n    const overridenId = params.data.id;\n    const exists = (await getDoc(doc(r.collection, overridenId))).exists();\n    if (exists) {\n      throw new Error(\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n      );\n    }\n\n    const createData = await client.parseDataAndUpload(\n      r,\n      overridenId,\n      params.data\n    );\n    if (!overridenId) {\n      throw new Error('id must be a valid string');\n    }\n    const createDocObj = { ...createData };\n    client.checkRemoveIdField(createDocObj, overridenId);\n    await client.addCreatedByFields(createDocObj);\n    await client.addUpdatedByFields(createDocObj);\n    const createDocObjTransformed = client.transformToDb(\n      resourceName,\n      createDocObj,\n      overridenId\n    );\n    log('Create', { docObj: createDocObj });\n    await setDoc(doc(r.collection, overridenId), createDocObjTransformed, {\n      merge: false,\n    });\n    return {\n      data: {\n        ...createDocObjTransformed,\n        id: overridenId,\n      },\n    };\n  }\n  const newId = fireWrapper.dbMakeNewId();\n  const data = await client.parseDataAndUpload(r, newId, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, newId);\n  await client.addCreatedByFields(docObj);\n  await client.addUpdatedByFields(docObj);\n  const docObjTransformed = client.transformToDb(resourceName, docObj, newId);\n  await setDoc(doc(r.collection, newId), docObjTransformed, { merge: false });\n  return {\n    data: {\n      ...docObjTransformed,\n      id: newId,\n    },\n  };\n}\n","import { deleteDoc, doc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\nimport { DeleteSoft } from './Delete.Soft';\n\nexport async function Delete<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm, options } = client;\n  if (options.softDelete) {\n    return DeleteSoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log('apiDelete', { resourceName, resource: r, params });\n  try {\n    const id = params.id + '';\n\n    await deleteDoc(doc(r.collection, id));\n  } catch (error) {\n    throw new Error(error as any);\n  }\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log, logError } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function DeleteSoft<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm } = client;\n  const id = params.id + '';\n  const r = await rm.TryGetResource(resourceName);\n  log('DeleteSoft', { resourceName, resource: r, params });\n  const docObj = { deleted: true };\n  await client.addUpdatedByFields(docObj);\n\n  updateDoc(doc(r.collection, id), docObj).catch((error) => {\n    logError('DeleteSoft error', { error });\n  });\n\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { doc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\nimport { DeleteManySoft } from './DeleteMany.Soft';\n\nexport async function DeleteMany(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { options, rm, fireWrapper } = client;\n  if (options.softDelete) {\n    return DeleteManySoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log('DeleteMany', { resourceName, resource: r, params });\n  const returnData: ra.Identifier[] = [];\n  const batch = fireWrapper.dbCreateBatch();\n  for (const id of params.ids) {\n    const idStr = id + '';\n    const docToDelete = doc(r.collection, idStr);\n    batch.delete(docToDelete);\n    returnData.push(id);\n  }\n\n  try {\n    await batch.commit();\n  } catch (error) {\n    throw new Error(error as any);\n  }\n  return { data: returnData };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log, logError } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function DeleteManySoft(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { rm } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log('DeleteManySoft', { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + '';\n      const docObj = { deleted: true };\n      await client.addUpdatedByFields(docObj);\n      updateDoc(doc(r.collection, idStr), docObj).catch((error) => {\n        logError('apiSoftDeleteMany error', { error });\n      });\n      return idStr;\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n"],"names":["sortArray","data","field","dir","sort","a","b","get","rawB","isAsc","Number","isFinite","rawA","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","value","searchField","searchValue","tree","leaves","obj","path","key","hasOwnProperty","objVal","Array","recursivelyWalk","currentPath","push","getFieldReferences","apply","filter","row","reduce","acc","cur","res","searchThis","toString","includes","isArray","doesRowMatch","LogNoOp","LoggerBase","title","cacheEnabledKey","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","console","log","bind","warn","error","logger","KEY_SINGLE","logError","dispatch","eventName","fileName","eventMonitor","document","getElementById","event","CustomEvent","detail","dispatchEvent","REF_INDENTIFIER","translateDocFromFirestore","parsedDoc","refdocs","recusivelyCheckObjectValue","result","input","fieldPath","toDate","index","isInputADocReference","documentReference","refDocPath","id","firestore","parent","recursivelyMapStorageUrls","fireWrapper","fieldValue","_exit","_temp2","_result","Promise","all","_recursivelyMapStorag","resolve","_recursivelyMapStorag2","e","reject","isFileField","has","getDownloadURL","ref","storage","src","then","_fieldValue$src","_catch","parseFireStoreDocument","doc","logWarn","refDocs","d","set","applyRefDocs","dataWithRefs","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","length","slice","joinPaths","call","arguments","translateDocToFirestore","uploads","recusivelyParseObjectValue","fieldDotsPath","refPath","fieldSlashesPath","rawFile","FirebaseWrapper","inputOptions","firebaseConfig","_app","_firestore","_storage","_auth","options","optionsSafe","window","app","apps","getApps","getApp","initializeApp","ObtainFirebaseApp","getFirestore","getStorage","auth","getAuth","dbGetCollection","absolutePath","collection","_proto","dbCreateBatch","writeBatch","dbMakeNewId","OnUserLogout","callBack","onAuthStateChanged","user","isLoggedOut","putFile","storagePath","task","uploadBytesResumable","rej","downloadUrl","taskResult","t","url","getStorageDownloadUrl","fieldSrc","serverTimestamp","firestoreServerTimestamp","authSetPersistence","persistenceInput","persistenceResolved","browserLocalPersistence","inMemoryPersistence","browserSessionPersistence","setPersistence","authSigninEmailPassword","email","password","signInWithEmailAndPassword","authSignOut","signOut","authGetUserLoggedIn","_this5","currentUser","unsubscribe","GetUserLogin","GetApp","db","AuthClient","optionsInput","persistence","prototype","HandleAuthLogin","params","_this","username","getUserLogin","HandleAuthLogout","HandleAuthError","errorHttp","retrieveStatusTxt","status","HandleAuthCheck","HandleGetPermissions","_this3","getIdTokenResult","token","claims","HandleGetIdentity","_this4","_ref","displayName","photoURL","uid","fullName","avatar","HandleGetJWTAuthTime","authTime","HandleGetJWTExpirationTime","_this6","expirationTime","HandleGetJWTSignInProvider","_this7","signInProvider","HandleGetJWTIssuedAtTime","_this8","issuedAtTime","HandleGetJWTToken","_this9","ResourceManager","flogger","resources","TryGetResource","resourceName","refresh","collectionQuery","_this2","TryGetResourcePromise","RefreshResource","_temp","GetResource","resource","initPath","_this4$options","_this4$options$lazyLo","lazyLoading","enabled","collectionRef","collectionOrQuery","applyQuery","getDocs","newDocs","list","forEach","logDocument","docs","collectionPath","GetSingleDoc","docId","getDoc","docSnap","exists","hasBeenInited","pathAbsolute","allResources","getUserIdentifier","associateUsersById","getCurrentUserId","getCurrentUserEmail","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","transformToDb","documentData","parseDataAndUpload","r","docPath","u","parseStoragePath","useFileName","fileNameBits","File","name","fileExtension","pop","useFileNamesInStorage","saveFile","link","addCreatedByFields","AddCreatedByFields","disableMeta","currentUserIdentifier","createAtSelector","GetSelectorsCreateAt","renameMetaFields","created_at","casing","metaFieldCasing","defautCase","createBySelector","GetSelectorsCreateBy","created_by","addUpdatedByFields","AddUpdatedByFields","updateAtSelector","GetSelectorsUpdateAt","updated_at","updateBySelector","updated_by","GetSelectorsUpdateBy","_this4$fireWrapper$pu","on","snapshot","progress","bytesTransferred","totalBytes","state","relativeFilePaths","storageError","pact","s","_Pact","o","_settle","v","observer","onFulfilled","onRejected","callback","thenable","getQueryCursor","btoa","JSON","stringify","_extends","docSnapshot","paramsToQuery","defaultParamsToQueryOptions","paginationConstraints","noPagination","query","filterConstraints","sortConstraints","withPagination","concat","filters","entries","flatMap","where","isNaN","parsedOrder","order","toLocaleLowerCase","orderBy","getSortConstraints","getPaginationConstraints","pagination","queryConstraints","_params$pagination","perPage","page","limit","queryCursor","_temp3","startAfter","findLastQueryCursor","pageLimit","currentPage","newQuery","lastQueryCursor","snapshots","docsLength","currentPageParams","_getQueryCursor","_findLastQueryCursor","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","FirebaseLazyLoadingClient","client","apiGetList","tryGetResource","softDelete","resultsCount","message","total","allCursorsKey","localCursorKeys","newCursors","parse","setQueryCursor","getNextPageParams","getCountFromServer","count","parsedData","_data$total","apiGetManyReference","_extends2","filterWithTarget","target","_ref2","_exit2","_temp5","_result2","_temp6","_temp4","AuthProvider","VerifyAuthProviderArgs","logging","login","logout","checkAuth","checkError","getPermissions","getIdentity","getAuthUser","getJWTAuthTime","getJWTExpirationTime","getJWTSignInProvider","getJWTClaims","getJWTToken","_options$firestoreCos","_options$firestoreCos2","run","cb","_cb","errorMsg","code","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","verifyDataProviderArgs","ResetCount","shouldReset","docCount","_options$lazyLoading","incrementBy","currentCountRaw","parseInt","incremented","incrementRead","MakeFirestoreLogger","firestoreCostsLogger","persistCount","getList","lazyClient","filterSafe","dataPage","softDeleted","filteredData","pageStart","fetchedData","GetList","getOne","GetOne","dataSingle","getMany","GetMany","ids","idObj","matchDocSnaps","permittedData","matches","snap","getManyReference","GetManyReference","targetField","targetIdFilter","targetValue","_params$sort","update","Update","docObj","updateDoc","docObjTransformed","updateMany","UpdateMany","idStr","returnData","create","Create","newId","setDoc","merge","hasOverridenDocId","overridenId","_getDoc","createData","createDocObj","createDocObjTransformed","_data","Delete","previousData","DeleteSoft","deleteDoc","deleteMany","DeleteMany","DeleteManySoft","_step","_iterator","done","docToDelete","batch","commit"],"mappings":"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"}